#!/usr/bin/env python3
"""Generate a self-contained AI prompt for decompiling a function.

Finds a simple unmatched function (or uses a specified one), gathers all
necessary context (assembly, dependencies, source file, types), and produces
a prompt that can be fed directly to an AI assistant.

Usage:
    python3 tools/gen_prompt.py                          # auto-select
    python3 tools/gen_prompt.py <function_name>          # specific function
    python3 tools/gen_prompt.py --module game --max-size 100
    python3 tools/gen_prompt.py <function_name> --output prompt.md
"""

import argparse
import json
import os
import re
import subprocess
import sys

# Add tools directory to path for imports
script_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, script_dir)

import decomp_helper
import feedback_diff
from feedback_diff import run_objdiff, find_unit_for_symbol, get_symbol_data

ROOT_DIR = os.path.dirname(script_dir)
CONFIG_BASE = os.path.join(ROOT_DIR, "config/GYQE01")


# ---------------------------------------------------------------------------
# Prompt template sections (embedded so the tool is self-contained, no AI)
# ---------------------------------------------------------------------------

BACKGROUND = """\
This is a matching decompilation project for Mario Superstar Baseball (GameCube, GYQE01).
The goal is to write C code that, when compiled with Metrowerks CodeWarrior GC/1.3.2,
produces the exact same binary as the original game.

Target architecture: PowerPC (Gekko/Broadway).
Compiler: Metrowerks CodeWarrior for GameCube, version 1.3.2.
Language: C (not C++)."""

COMPILER_PATTERNS = """\
### Global Address Re-loading
The compiler re-loads the base address of a global variable (using `lis`/`addi`) even if
already in a register. Creating a local pointer (`Type* p = &g_Global;`) causes the
compiler to hold the address in one register, which mismatches the original. Use direct
global access (`g_Global.field = ...;`) in distinct logical blocks instead.

### Structure Assignments and Update-Form Instructions
The binary uses "load/store with update" instructions (`lfsu`, `stfsu`). These are
generated by structure-level assignments (`dst.pos = src.pos;`), NOT by individual field
copies (`dst.x = src.x; dst.z = src.z;`).

### Register Steering ("Anchoring")
Registers `r31`/`r30` are typically used for major object base pointers. Define a local
pointer at the exact line where assembly first allocates the base register. Defining it
at the top of the function causes the compiler to use a different register.

### ROData Ordering
Float constants are stored in `.rodata` in the order first encountered in C code. If
your code references `1.0f` before `0.0f` but the original did the reverse, rodata
labels will mismatch. Order your constant references to match the assembly.

### Casting and Sign Extension
Use explicit casts to match `extsh` (sign-extend halfword) and `extsb` (sign-extend byte).
Ensure `lwz` vs `lhz` vs `lbz` matches your struct field types (u32 vs u16 vs u8)."""

CODE_RULES = """\
- NEVER use pointer arithmetic with manual offsets. Always define proper structs.
- NEVER use `void*` as an argument or return type. Define typed structs instead.
- All struct field accesses must use `->` or `.` operators.
- When you see `*(type*)((u8*)ptr + 0xNN)`, create a struct with a field at that offset.
- Use `u8 _pad[0xNN];` for unknown fields between known offsets.
- Check the existing header file for the source file â€” structs may already be defined."""

TYPES_REFERENCE = """\
```c
typedef int BOOL;
typedef signed char s8;
typedef signed short s16;
typedef signed long s32;
typedef signed long long s64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;
typedef float f32;
typedef double f64;
#define TRUE  1
#define FALSE 0
#define NULL  ((void*)0)
```"""


# INSTRUCTIONS_TEMPLATE = """\
# Implement the function `{func}` in the source file shown above. Replace the existing
# stub with your implementation.

# After implementing:
# 1. Build: `ninja`
# 2. Verify: `python3 tools/feedback_diff.py {func}`
# 3. The ONLY acceptable result is `MATCH!`. A function that compiles is NOT necessarily matched.

# If you need to define new structs, add them to the appropriate header file.
# Keep the code style consistent with the surrounding functions in the source file."""
INSTRUCTIONS_TEMPLATE = """\
Give Instructions on how to Implement the function `{func}` in the source file shown above. Replace the existing
stub with your implementation.

If you need to define new structs, add them to the appropriate header file.
Keep the code style consistent with the surrounding functions in the source file.

Your instructions will be passed to another AI model to generate the implementation.  Make your instructions clear and concise.
One special Note, if you are defining new Structs, instruct the AI to search for a definition for that struct/variable BEFORE creating a new version.
Don't ask to work on the next function.  Your goal is to only work on the current function.
Instruct the AI to use 'ninja' to verify the whole project builds.  Don't check the match, the user will do that.
"""


# ---------------------------------------------------------------------------
# Context gathering (reuses decomp_helper logic, no AI)
# ---------------------------------------------------------------------------

def find_function(module, max_size, min_size):
    """Find an easy unmatched function from report.json."""
    report_path = os.path.join(ROOT_DIR, "report.json")
    if not os.path.exists(report_path):
        print("Error: report.json not found. Run 'ninja report' first.", file=sys.stderr)
        sys.exit(1)

    with open(report_path, "r") as f:
        data = json.load(f)

    candidates = []
    modules = (module,) if module else ("game", "menus")

    for unit in data.get("units", []):
        unit_name = unit.get("name", "")
        if unit.get("measures", {}).get("matched_code_percent", 0) == 100.0:
            continue

        category = "dol"
        if unit_name.startswith("game/"):
            category = "game"
        elif unit_name.startswith("menus/"):
            category = "menus"
        elif unit_name.startswith("challenge/"):
            category = "challenge"

        if category not in modules:
            continue

        for func in unit.get("functions", []):
            size = int(func.get("size", 0))
            if size < min_size or (max_size and size > max_size):
                continue
            fm = func.get("measures", {})
            if fm.get("matched_code_percent", 0) >= 25.0:
                continue
            candidates.append({
                "name": func.get("name", ""),
                "size": size,
                "unit": unit_name,
                "category": category,
            })

    candidates.sort(key=lambda x: (x["size"], x["name"]))

    # Return first candidate that has a locatable source file and isn't already matched
    for c in candidates:
        info = locate_function(c["name"])
        if not info:
            continue
        
        # Real-time check via objdiff
        match_percent = get_match_percent(c["name"])
        if match_percent is not None and match_percent >= 25.0:
            continue

        # Check if already matched via objdiff (redundant with above but keeps logic safe)
        if match_percent == 100.0:
            continue
            
        return c["name"]

    return None


def get_match_percent(func_name):
    """Get the current match percentage from objdiff."""
    unit = find_unit_for_symbol(func_name)
    if not unit:
        return None
    
    data = run_objdiff(unit, func_name)
    if not data:
        return None
        
    _, right_sym = get_symbol_data(data, func_name)
    if right_sym and "match_percent" in right_sym:
        return float(right_sym["match_percent"])
    return 0.0


def locate_function(func_name):
    """Find source file, module, and address for a function. Returns dict or None."""
    for m in ("", "game", "menus", "challenge"):
        sym_file = os.path.join(CONFIG_BASE, m, "symbols.txt") if m else os.path.join(CONFIG_BASE, "symbols.txt")
        symbols = decomp_helper.parse_symbols(sym_file)
        if func_name in symbols:
            addr = symbols[func_name]["addr"]
            split_file = os.path.join(CONFIG_BASE, m, "splits.txt") if m else os.path.join(CONFIG_BASE, "splits.txt")
            splits = decomp_helper.parse_splits(split_file)
            found_file = decomp_helper.find_file_for_address(splits, addr)
            if found_file:
                return {"module": m, "addr": addr, "file": found_file}
    return None


def get_assembly(func_name, info):
    """Extract the target assembly for a function."""
    module = info["module"]
    rel_path = os.path.splitext(info["file"])[0] + ".s"
    if module:
        asm_path = os.path.join(ROOT_DIR, f"build/GYQE01/{module}/asm", rel_path)
    else:
        asm_path = os.path.join(ROOT_DIR, "build/GYQE01/asm", rel_path)

    asm = decomp_helper.extract_asm(asm_path, func_name)
    if asm:
        return asm

    # Fallback: search asm directory
    search_root = os.path.join(ROOT_DIR, f"build/GYQE01/{module}/asm") if module else os.path.join(ROOT_DIR, "build/GYQE01/asm")
    if os.path.exists(search_root):
        for root, _, files in os.walk(search_root):
            for f in files:
                if f.endswith(".s"):
                    result = decomp_helper.extract_asm(os.path.join(root, f), func_name)
                    if result:
                        return result
    return None


def extract_deps_and_symbols(asm_text):
    """Parse assembly to find bl dependencies and referenced symbols."""
    deps = set()
    syms = set()
    for line in asm_text.splitlines():
        bl_match = re.search(r"\bbl\s+([a-zA-Z0-9_]+)", line)
        if bl_match:
            deps.add(bl_match.group(1))
        sym_match = re.search(r"\b(lbl_[0-9A-Fa-f_]+|g_[a-zA-Z0-9_]+)\b", line)
        if sym_match:
            syms.add(sym_match.group(1))
    return sorted(deps), sorted(syms)


def find_signature(symbol):
    """Search include/ for a function signature."""
    include_dir = os.path.join(ROOT_DIR, "include")
    try:
        result = subprocess.run(
            ["grep", "-rE", rf"\b{re.escape(symbol)}\s*\(", include_dir],
            capture_output=True, text=True,
        )
        if result.returncode == 0:
            for line in result.stdout.splitlines():
                if ";" in line or "{" in line:
                    return line.strip()
    except Exception:
        pass
    return None


def read_source_file(info):
    """Read the source .c file content."""
    src_path = os.path.join(ROOT_DIR, "src", info["file"])
    if os.path.exists(src_path):
        with open(src_path, "r") as f:
            return src_path, f.read()
    return src_path, None


def read_header_file(info):
    """Read the primary header for the source file."""
    # Source file is e.g. "game/rep_1838.c", header is "include/game/rep_1838.h"
    header_rel = os.path.splitext(info["file"])[0] + ".h"
    header_path = os.path.join(ROOT_DIR, "include", header_rel)
    if os.path.exists(header_path):
        with open(header_path, "r") as f:
            return header_path, f.read()
    return header_path, None


def run_feedback(func_name):
    """Run feedback_diff.py and return stdout."""
    try:
        result = subprocess.run(
            ["python3", os.path.join(script_dir, "feedback_diff.py"), func_name],
            capture_output=True, text=True, cwd=ROOT_DIR,
        )
        return result.stdout
    except Exception:
        return None


def run_m2c(func_name):
    """Run m2c_helper.py and return stdout."""
    try:
        result = subprocess.run(
            ["python3", os.path.join(script_dir, "m2c_helper.py"), func_name],
            capture_output=True, text=True, cwd=ROOT_DIR,
        )
        if result.returncode == 0:
            lines = result.stdout.splitlines()
            # Filter out decompctx logging
            filtered = [l for l in lines if not l.startswith("Processing file")]
            return "\n".join(filtered)
    except Exception:
        pass
    return None


# ---------------------------------------------------------------------------
# Prompt assembly
# ---------------------------------------------------------------------------

def build_prompt(func_name, info, asm_text, deps, syms, src_path, src_content,
                 header_path, header_content, feedback, m2c_output):
    """Assemble the complete prompt."""
    sections = []

    sections.append(f"# Decompile: `{func_name}`\n")

    # Background
    sections.append("## Project Background\n")
    sections.append(BACKGROUND)

    # Types
    sections.append("\n## Core Types\n")
    sections.append(TYPES_REFERENCE)

    # Compiler patterns
    sections.append("\n## Compiler Behavior Patterns (Metrowerks CodeWarrior / PowerPC)\n")
    sections.append(COMPILER_PATTERNS)

    # Code rules
    sections.append("\n## Code Quality Rules\n")
    sections.append(CODE_RULES)

    # Function info
    sections.append(f"\n## Function Info\n")
    sections.append(f"- **Name**: `{func_name}`")
    sections.append(f"- **Address**: `{hex(info['addr'])}`")
    sections.append(f"- **Module**: `{info['module'] or 'main'}`")
    sections.append(f"- **Source file**: `src/{info['file']}`")

    # Assembly
    sections.append(f"\n## Target Assembly\n")
    sections.append(f"```asm\n{asm_text.strip()}\n```")

    # Dependencies
    if deps:
        sections.append(f"\n## Dependencies (bl calls)\n")
        for dep in deps:
            sig = find_signature(dep)
            if sig:
                sections.append(f"- `{dep}`: `{sig}`")
            else:
                sections.append(f"- `{dep}` (signature not found in headers)")

    # Referenced symbols
    if syms:
        sections.append(f"\n## Referenced Symbols\n")
        for sym in syms:
            sections.append(f"- `{sym}`")

    # Current feedback
    if feedback and "MATCH!" not in feedback:
        sections.append(f"\n## Current Diff (compiled vs target)\n")
        sections.append(f"```\n{feedback.strip()}\n```")

    # m2c approximate decomp
    if m2c_output:
        sections.append(f"\n## Approximate Decompilation (from m2c)\n")
        sections.append(f"```c\n{m2c_output.strip()}\n```")

    # Header file
    if header_content:
        rel = os.path.relpath(header_path, ROOT_DIR)
        sections.append(f"\n## Header: `{rel}`\n")
        sections.append(f"```c\n{header_content.strip()}\n```")

    # Source file
    if src_content:
        rel = os.path.relpath(src_path, ROOT_DIR)
        sections.append(f"\n## Source File: `{rel}`\n")
        sections.append(f"```c\n{src_content.strip()}\n```")

    # Instructions
    sections.append(f"\n## Instructions\n")
    sections.append(INSTRUCTIONS_TEMPLATE.format(func=func_name))

    return "\n".join(sections)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Generate an AI prompt for decompiling a function."
    )
    parser.add_argument(
        "function", nargs="?", default=None,
        help="Function name to decompile (auto-selects if omitted)",
    )
    parser.add_argument("--module", default=None, help="Filter by module (game, menus)")
    parser.add_argument("--max-size", type=int, default=None, help="Max function size in bytes")
    parser.add_argument("--min-size", type=int, default=8, help="Min function size (default: 8)")
    parser.add_argument("--output", "-o", default=None, help="Write prompt to file instead of stdout")
    args = parser.parse_args()

    # 1. Find or validate function
    if args.function:
        func_name = args.function
    else:
        print("Searching for an unmatched function...", file=sys.stderr)
        func_name = find_function(args.module, args.max_size, args.min_size)
        if not func_name:
            print("No suitable unmatched function found.", file=sys.stderr)
            sys.exit(1)
        print(f"Selected: {func_name}", file=sys.stderr)

    # 2. Locate function
    info = locate_function(func_name)
    if not info:
        print(f"Error: Could not locate {func_name} in symbols.", file=sys.stderr)
        sys.exit(1)

    # 3. Get assembly
    asm_text = get_assembly(func_name, info)
    if not asm_text:
        print(f"Error: Could not extract assembly for {func_name}.", file=sys.stderr)
        sys.exit(1)

    # 4. Extract deps and symbols from assembly
    deps, syms = extract_deps_and_symbols(asm_text)

    # 5. Read source and header files
    src_path, src_content = read_source_file(info)
    header_path, header_content = read_header_file(info)

    # 6. Get current feedback
    feedback = run_feedback(func_name)

    # 7. Run m2c
    m2c_output = run_m2c(func_name)

    # 8. Build prompt
    prompt = build_prompt(
        func_name, info, asm_text, deps, syms,
        src_path, src_content, header_path, header_content, feedback, m2c_output,
    )

    # 8. Output
    if args.output:
        with open(args.output, "w") as f:
            f.write(prompt)
        print(f"Prompt written to {args.output}", file=sys.stderr)
    else:
        print(prompt)


if __name__ == "__main__":
    main()
